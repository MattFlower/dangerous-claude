#!/bin/bash
#
# dangerous-claude - Run Claude Code in a sandboxed Docker container
#
# Usage:
#   dangerous-claude [OPTIONS] [DIRECTORIES...]
#
# Options:
#   --continue, -c      Continue the most recent conversation
#   --resume, -r ID     Resume a specific conversation by ID
#   --build             Force rebuild the Docker image locally
#   --init              Pull image (or build if customized)
#   --shell             Start a bash shell instead of Claude
#   --login             Run 'claude login' for Claude Max authentication
#   --help, -h          Show this help message
#
# Authentication:
#   - Claude Max: If logged in on host, it just works (shares ~/.claude)
#   - API Key: Set ANTHROPIC_API_KEY environment variable
#
# Examples:
#   dangerous-claude --login                    # First time: authenticate
#   dangerous-claude ./repo1 ./repo2
#   dangerous-claude --continue ./repo1
#   dangerous-claude --resume abc123 ./repo1 ./repo2 ./repo3
#

set -e

VERSION="1.1.4"

# Configuration
IMAGE_NAME="dangerous-claude"
REMOTE_IMAGE="ghcr.io/mattflower/dangerous-claude:latest"
CONTAINER_NAME="dangerous-claude-$$"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# State directory for persisting Claude conversations
# Shares with host's ~/.claude by default for plugin/MCP compatibility
CLAUDE_STATE_DIR="${CLAUDE_STATE_DIR:-$HOME/.claude}"

# Parse arguments
DIRECTORIES=()
CONTINUE_FLAG=""
RESUME_ID=""
FORCE_BUILD=false
INIT_IMAGE=false
START_SHELL=false
RUN_LOGIN=false

show_help() {
  sed -n '2,25p' "$0" | sed 's/^#//' | sed 's/^ //'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case $1 in
  --continue | -c)
    CONTINUE_FLAG="true"
    shift
    ;;
  --resume | -r)
    RESUME_ID="$2"
    shift 2
    ;;
  --build | build)
    FORCE_BUILD=true
    shift
    ;;
  --init)
    INIT_IMAGE=true
    shift
    ;;
  --shell | shell)
    START_SHELL=true
    shift
    ;;
  --login | login)
    RUN_LOGIN=true
    shift
    ;;
  --help | -h | help)
    show_help
    ;;
  --version | version)
    echo "dangerous-claude $VERSION"
    exit 0
    ;;
  -*)
    echo "Unknown option: $1"
    exit 1
    ;;
  *)
    DIRECTORIES+=("$1")
    shift
    ;;
  esac
done

# Create state directory if it doesn't exist
mkdir -p "$CLAUDE_STATE_DIR"

# Sync OAuth credentials from macOS Keychain to file (one-time seed)
# On macOS, Claude Code stores credentials in the Keychain, but Docker can't access it.
# This function extracts credentials and writes them to ~/.claude/.credentials.json
#
# IMPORTANT: This only syncs if the file doesn't exist or contains invalid JSON.
# Once a valid credentials file exists, we NEVER overwrite it from Keychain because:
#   1. The container may have refreshed the token (writing to the file)
#   2. The container CANNOT update the Keychain (no macOS Keychain access in Docker)
#   3. Therefore, Keychain credentials are always potentially stale after first use
#
# Returns: 0 always (errors are logged to stderr but don't stop container startup)
sync_keychain_credentials() {
  # Only run on macOS
  if [[ "$(uname)" != "Darwin" ]]; then
    return 0
  fi

  local credentials_file="$CLAUDE_STATE_DIR/.credentials.json"

  # Require jq for JSON validation
  if ! command -v jq &>/dev/null; then
    echo "Warning: jq is not installed, cannot sync Keychain credentials" >&2
    echo "  Install with: brew install jq" >&2
    return 0
  fi

  # If credentials file already exists with valid JSON, prefer it over Keychain
  # (Container may have refreshed tokens that Keychain doesn't have)
  if [ -f "$credentials_file" ] && [ ! -L "$credentials_file" ]; then
    if jq -e . "$credentials_file" &>/dev/null; then
      # File exists with valid JSON - don't overwrite
      return 0
    fi
    # File exists but is invalid JSON - will overwrite below
    echo "Warning: Existing credentials file is invalid JSON, will sync from Keychain" >&2
  fi

  # Security check: refuse to write if destination is a symlink
  if [ -L "$credentials_file" ]; then
    echo "Error: $credentials_file is a symlink, refusing to write credentials" >&2
    return 0
  fi

  # Known keychain service names used by Claude Code (check in order of preference)
  local keychain_services=(
    "Claude Code-credentials"
    "claude-credentials"
  )

  # Try to extract credentials from Keychain (try each known service name)
  local keychain_data=""
  for service in "${keychain_services[@]}"; do
    if keychain_data=$(security find-generic-password -s "$service" -w 2>/dev/null); then
      break
    fi
  done

  # No credentials in Keychain
  if [ -z "$keychain_data" ]; then
    return 0
  fi

  # Validate JSON from Keychain
  local normalized_data
  if ! normalized_data=$(printf '%s' "$keychain_data" | jq -cS . 2>/dev/null); then
    echo "Warning: Keychain credentials are not valid JSON, skipping sync" >&2
    return 0
  fi

  # Check for token expiration (warn but don't block - user may want to use expired token to trigger refresh)
  local expires_at
  expires_at=$(printf '%s' "$normalized_data" | jq -r '.claudeAiOauth.expiresAt // .oauthAccount.expiresAt // empty' 2>/dev/null)
  if [ -n "$expires_at" ] && [[ "$expires_at" =~ ^[0-9]+$ ]]; then
    local now_ms
    now_ms=$(($(date +%s) * 1000))
    if [ "$expires_at" -lt "$now_ms" ]; then
      echo "Warning: OAuth token from Keychain appears to be expired. You may need to run: dangerous-claude --login" >&2
    fi
  fi

  # Write credentials atomically using temp file + mv with file locking
  local temp_file
  temp_file=$(mktemp "$CLAUDE_STATE_DIR/.credentials.tmp.XXXXXX") || {
    echo "Error: Failed to create temp file for credentials sync" >&2
    return 0
  }

  # Use a lock file to prevent race conditions with concurrent dangerous-claude instances
  local lock_file="$CLAUDE_STATE_DIR/.credentials.lock"
  (
    # Try to acquire lock (wait up to 5 seconds)
    if command -v flock &>/dev/null; then
      flock -w 5 200 || {
        echo "Warning: Could not acquire lock for credentials sync" >&2
        rm -f "$temp_file" 2>/dev/null
        return 0
      }
    fi

    # Re-check if file was created while waiting for lock
    if [ -f "$credentials_file" ] && [ ! -L "$credentials_file" ]; then
      if jq -e . "$credentials_file" &>/dev/null; then
        rm -f "$temp_file" 2>/dev/null
        return 0
      fi
    fi

    # Set permissions before writing sensitive data
    if ! chmod 600 "$temp_file"; then
      echo "Error: Failed to set permissions on temp file" >&2
      rm -f "$temp_file" 2>/dev/null
      return 0
    fi

    # Write normalized JSON to temp file
    if ! printf '%s\n' "$normalized_data" > "$temp_file"; then
      echo "Error: Failed to write credentials to temp file" >&2
      rm -f "$temp_file" 2>/dev/null
      return 0
    fi

    # Final symlink check before move
    if [ -L "$credentials_file" ]; then
      echo "Error: $credentials_file became a symlink, refusing to write" >&2
      rm -f "$temp_file" 2>/dev/null
      return 0
    fi

    # Atomic move to final location
    if ! mv "$temp_file" "$credentials_file"; then
      echo "Error: Failed to move credentials file into place" >&2
      rm -f "$temp_file" 2>/dev/null
      return 0
    fi

    echo "Synced OAuth credentials from macOS Keychain" >&2
  ) 200>"$lock_file"

  # Clean up lock file (non-critical if this fails)
  rm -f "$lock_file" 2>/dev/null
}

# Prepare config files for build (copy from .example if not present)
prepare_config_files() {
  # packages.apt - apt packages to install
  if [ ! -f "$SCRIPT_DIR/packages.apt" ]; then
    if [ -f "$SCRIPT_DIR/packages.apt.example" ]; then
      cp "$SCRIPT_DIR/packages.apt.example" "$SCRIPT_DIR/packages.apt"
      echo "Created packages.apt from packages.apt.example"
    else
      touch "$SCRIPT_DIR/packages.apt"
    fi
  fi

  # sdkman.txt - SDKMAN tools to install
  if [ ! -f "$SCRIPT_DIR/sdkman.txt" ]; then
    if [ -f "$SCRIPT_DIR/sdkman.txt.example" ]; then
      cp "$SCRIPT_DIR/sdkman.txt.example" "$SCRIPT_DIR/sdkman.txt"
      echo "Created sdkman.txt from sdkman.txt.example"
    else
      touch "$SCRIPT_DIR/sdkman.txt"
    fi
  fi
}

# Check if config files have been customized from the examples
is_customized() {
  # If packages.apt exists and differs from example, it's customized
  if [ -f "$SCRIPT_DIR/packages.apt" ] && [ -f "$SCRIPT_DIR/packages.apt.example" ]; then
    if ! diff -q "$SCRIPT_DIR/packages.apt" "$SCRIPT_DIR/packages.apt.example" &>/dev/null; then
      return 0
    fi
  fi

  # If sdkman.txt exists and differs from example, it's customized
  if [ -f "$SCRIPT_DIR/sdkman.txt" ] && [ -f "$SCRIPT_DIR/sdkman.txt.example" ]; then
    if ! diff -q "$SCRIPT_DIR/sdkman.txt" "$SCRIPT_DIR/sdkman.txt.example" &>/dev/null; then
      return 0
    fi
  fi

  return 1
}

# Build locally
build_image() {
  echo "Building Docker image..."
  prepare_config_files
  docker build -t "$IMAGE_NAME" "$SCRIPT_DIR"
  echo ""
}

# Pull from GitHub Container Registry
pull_image() {
  echo "Pulling Docker image from GitHub Container Registry..."
  if docker pull "$REMOTE_IMAGE"; then
    docker tag "$REMOTE_IMAGE" "$IMAGE_NAME"
    echo ""
  else
    echo "Failed to pull image, building locally instead..."
    build_image
  fi
}

# Acquire image: build or pull as appropriate
if [ "$FORCE_BUILD" = true ]; then
  build_image
  echo "Docker image built successfully."
  exit 0
elif [ "$INIT_IMAGE" = true ]; then
  # Smart pull-or-build: pull unless customized
  if is_customized; then
    echo "Custom configuration detected."
    build_image
  else
    pull_image
  fi
  echo "Docker image ready."
  exit 0
elif ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
  # Image doesn't exist locally
  if is_customized; then
    echo "Custom configuration detected."
    build_image
  else
    pull_image
  fi
fi

# Sync credentials from macOS Keychain before starting container
sync_keychain_credentials

# Build volume mounts
VOLUME_ARGS=()

# Mount Claude state for conversation persistence (symlinked to ~/.claude at runtime)
VOLUME_ARGS+=("-v" "$CLAUDE_STATE_DIR:/mnt/claude-data")

# Mount ~/.claude.json to a staging location (read-only)
# The entrypoint will copy it to the actual location, so each container
# gets its own writable copy and avoids conflicts when running multiple instances
CLAUDE_JSON="$HOME/.claude.json"
if [ -f "$CLAUDE_JSON" ]; then
  VOLUME_ARGS+=("-v" "$CLAUDE_JSON:/mnt/claude-config/.claude.json:ro")
fi

# Mount git config so commits appear as the user
if [ -f "$HOME/.gitconfig" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.gitconfig:/home/claude/.gitconfig:ro")
fi

# Mount Gradle directory for shared caches and configs
if [ -d "$HOME/.gradle" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.gradle:/home/claude/.gradle")
fi

# Mount Maven directory for shared caches and configs
if [ -d "$HOME/.m2" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.m2:/home/claude/.m2")
fi

# Function to check if a directory is a git worktree
is_git_worktree() {
  local dir="$1"
  local git_file="$dir/.git"
  # Worktrees have a .git file (not directory) containing "gitdir: ..."
  [ -f "$git_file" ] && grep -q "^gitdir:" "$git_file" 2>/dev/null
}

# Mount each directory and build ordered list for entrypoint
WORKSPACE_ORDER=()
for dir in "${DIRECTORIES[@]}"; do
  # Get absolute path
  abs_path="$(cd "$dir" 2>/dev/null && pwd)" || {
    echo "Error: Directory not found: $dir"
    exit 1
  }

  # Use the directory name as the mount point
  dir_name="$(basename "$abs_path")"

  VOLUME_ARGS+=("-v" "$abs_path:/workspace/$dir_name")
  WORKSPACE_ORDER+=("/workspace/$dir_name")
  echo "Mounting: $abs_path -> /workspace/$dir_name"

  # Warn if this is a git worktree
  if is_git_worktree "$abs_path"; then
    echo ""
    echo "  WARNING: This is a git worktree."
    echo "  Git commits will NOT work without access to the parent repository."
    echo "  File reading and editing will work normally."
    echo "  To enable commits, mount the main repository instead."
    echo ""
  fi
done

# If no directories specified, mount current directory
if [ ${#DIRECTORIES[@]} -eq 0 ]; then
  abs_path="$(pwd)"
  dir_name="$(basename "$abs_path")"
  VOLUME_ARGS+=("-v" "$abs_path:/workspace/$dir_name")
  WORKSPACE_ORDER+=("/workspace/$dir_name")
  echo "Mounting current directory: $abs_path -> /workspace/$dir_name"
fi

echo ""

# Build environment variables
ENV_ARGS=(
  "-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY"
)

# Prepare env.txt from example if not present
if [ ! -f "$SCRIPT_DIR/env.txt" ]; then
  if [ -f "$SCRIPT_DIR/env.txt.example" ]; then
    cp "$SCRIPT_DIR/env.txt.example" "$SCRIPT_DIR/env.txt"
  else
    touch "$SCRIPT_DIR/env.txt"
  fi
fi

# Pass environment variables listed in env.txt
if [ -f "$SCRIPT_DIR/env.txt" ]; then
  while IFS= read -r var_name || [ -n "$var_name" ]; do
    # Skip comments and empty lines
    [[ "$var_name" =~ ^#.*$ || -z "$var_name" ]] && continue
    # Only pass if the variable is set in the environment
    if [ -n "${!var_name}" ]; then
      ENV_ARGS+=("-e" "$var_name=${!var_name}")
    fi
  done < "$SCRIPT_DIR/env.txt"
fi

if [ -n "$CONTINUE_FLAG" ]; then
  ENV_ARGS+=("-e" "CLAUDE_CONTINUE=true")
fi

if [ -n "$RESUME_ID" ]; then
  ENV_ARGS+=("-e" "CLAUDE_RESUME=$RESUME_ID")
fi

# Pass workspace directory order to entrypoint (colon-separated)
if [ ${#WORKSPACE_ORDER[@]} -gt 0 ]; then
  WORKSPACE_ORDER_STR=$(IFS=:; echo "${WORKSPACE_ORDER[*]}")
  ENV_ARGS+=("-e" "WORKSPACE_ORDER=$WORKSPACE_ORDER_STR")
fi

# Determine the command to run
if [ "$RUN_LOGIN" = true ]; then
  DOCKER_CMD="claude login"
elif [ "$START_SHELL" = true ]; then
  DOCKER_CMD="bash"
else
  DOCKER_CMD=""
fi

# Run the container
exec docker run \
  --rm \
  -it \
  --name "$CONTAINER_NAME" \
  "${VOLUME_ARGS[@]}" \
  "${ENV_ARGS[@]}" \
  "$IMAGE_NAME" \
  $DOCKER_CMD
