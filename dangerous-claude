#!/bin/bash
#
# dangerous-claude - Run Claude Code in a sandboxed Docker container
#
# Usage:
#   dangerous-claude [OPTIONS] [DIRECTORIES...]
#
# Options:
#   --continue, -c      Continue the most recent conversation
#   --resume, -r ID     Resume a specific conversation by ID
#   --build             Force rebuild the Docker image locally
#   --init              Pull image (or build if customized)
#   --upgrade           Update dangerous-claude to the latest version
#   --shell             Start a bash shell instead of Claude
#   --login             Run 'claude login' for Claude Max authentication
#   --docker            Enable Docker access inside the container
#   --help, -h          Show this help message
#
# Authentication:
#   - Claude Max: If logged in on host, it just works (shares ~/.claude)
#   - API Key: Set ANTHROPIC_API_KEY environment variable
#
# Examples:
#   dangerous-claude --login                    # First time: authenticate
#   dangerous-claude ./repo1 ./repo2
#   dangerous-claude --continue ./repo1
#   dangerous-claude --resume abc123 ./repo1 ./repo2 ./repo3
#

set -e

VERSION="1.2.1"

# Configuration
IMAGE_NAME="dangerous-claude"
REMOTE_IMAGE="ghcr.io/mattflower/dangerous-claude:latest"
CONTAINER_NAME="dangerous-claude-$$"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# State directory for persisting Claude conversations
# Shares with host's ~/.claude by default for plugin/MCP compatibility
CLAUDE_STATE_DIR="${CLAUDE_STATE_DIR:-$HOME/.claude}"

# Parse arguments
DIRECTORIES=()
CONTINUE_FLAG=""
RESUME_ID=""
FORCE_BUILD=false
INIT_IMAGE=false
RUN_UPGRADE=false
START_SHELL=false
RUN_LOGIN=false
ENABLE_DOCKER=false

show_help() {
  sed -n '2,27p' "$0" | sed 's/^#//' | sed 's/^ //'
  exit 0
}

while [[ $# -gt 0 ]]; do
  case $1 in
  --continue | -c)
    CONTINUE_FLAG="true"
    shift
    ;;
  --resume | -r)
    RESUME_ID="$2"
    shift 2
    ;;
  --build | build)
    FORCE_BUILD=true
    shift
    ;;
  --init)
    INIT_IMAGE=true
    shift
    ;;
  --upgrade | upgrade)
    RUN_UPGRADE=true
    shift
    ;;
  --shell | shell)
    START_SHELL=true
    shift
    ;;
  --login | login)
    RUN_LOGIN=true
    shift
    ;;
  --docker)
    ENABLE_DOCKER=true
    shift
    ;;
  --help | -h | help)
    show_help
    ;;
  --version | version)
    echo "dangerous-claude $VERSION"
    exit 0
    ;;
  -*)
    echo "Unknown option: $1"
    exit 1
    ;;
  *)
    DIRECTORIES+=("$1")
    shift
    ;;
  esac
done

# Create state directory if it doesn't exist
mkdir -p "$CLAUDE_STATE_DIR"

# Variable to store API key extracted from keychain (used later in ENV_ARGS)
KEYCHAIN_API_KEY=""

# Sync OAuth credentials from macOS Keychain to file (one-time seed)
# On macOS, Claude Code stores credentials in the Keychain, but Docker can't access it.
# This function handles two credential types:
#   1. OAuth tokens (JSON) - written to ~/.claude/.credentials.json
#   2. API keys (sk-ant-...) - stored in KEYCHAIN_API_KEY for passing via env var
#
# For OAuth tokens: only syncs if the file doesn't exist or contains invalid JSON.
# Once a valid credentials file exists, we NEVER overwrite it from Keychain because:
#   1. The container may have refreshed the token (writing to the file)
#   2. The container CANNOT update the Keychain (no macOS Keychain access in Docker)
#   3. Therefore, Keychain credentials are always potentially stale after first use
#
# Returns: 0 always (errors are logged to stderr but don't stop container startup)
sync_keychain_credentials() {
  # Only run on macOS
  if [[ "$(uname)" != "Darwin" ]]; then
    return 0
  fi

  local credentials_file="$CLAUDE_STATE_DIR/.credentials.json"

  # Require jq for JSON validation
  if ! command -v jq &>/dev/null; then
    echo "Warning: jq is not installed, cannot sync Keychain credentials" >&2
    echo "  Install with: brew install jq" >&2
    return 0
  fi

  # If credentials file already exists with valid JSON, prefer it over Keychain
  # (Container may have refreshed tokens that Keychain doesn't have)
  if [ -f "$credentials_file" ] && [ ! -L "$credentials_file" ]; then
    if jq -e . "$credentials_file" &>/dev/null; then
      # File exists with valid JSON - don't overwrite
      return 0
    fi
    # File exists but is invalid JSON - will overwrite below
    echo "Warning: Existing credentials file is invalid JSON, will sync from Keychain" >&2
  fi

  # Security check: refuse to write if destination is a symlink
  if [ -L "$credentials_file" ]; then
    echo "Error: $credentials_file is a symlink, refusing to write credentials" >&2
    return 0
  fi

  # Known keychain service names used by Claude Code (check in order of preference)
  # - "Claude Code-credentials": Claude Max/Pro subscription OAuth
  # - "Claude Code": Anthropic Console (API billing) - may store API key or OAuth
  local keychain_services=(
    "Claude Code-credentials"
    "Claude Code"
    "claude-credentials"
  )

  # Try to extract credentials from Keychain (try each known service name)
  local keychain_data=""
  local found_service=""
  for service in "${keychain_services[@]}"; do
    if keychain_data=$(security find-generic-password -s "$service" -w 2>/dev/null); then
      found_service="$service"
      break
    fi
  done

  # No credentials in Keychain
  if [ -z "$keychain_data" ]; then
    return 0
  fi

  # Check if this is a raw API key (starts with sk-ant-)
  # Anthropic Console (API billing) stores API keys directly, not OAuth JSON
  if [[ "$keychain_data" == sk-ant-* ]]; then
    KEYCHAIN_API_KEY="$keychain_data"
    echo "Found API key in macOS Keychain (service: $found_service)" >&2
    return 0
  fi

  # Otherwise, it should be JSON OAuth credentials
  # Validate JSON from Keychain
  local normalized_data
  if ! normalized_data=$(printf '%s' "$keychain_data" | jq -cS . 2>/dev/null); then
    echo "Warning: Keychain credentials are not valid JSON, skipping sync" >&2
    return 0
  fi

  # Check for token expiration (warn but don't block - user may want to use expired token to trigger refresh)
  local expires_at
  expires_at=$(printf '%s' "$normalized_data" | jq -r '.claudeAiOauth.expiresAt // .oauthAccount.expiresAt // empty' 2>/dev/null)
  if [ -n "$expires_at" ] && [[ "$expires_at" =~ ^[0-9]+$ ]]; then
    local now_ms
    now_ms=$(($(date +%s) * 1000))
    if [ "$expires_at" -lt "$now_ms" ]; then
      echo "Warning: OAuth token from Keychain appears to be expired. You may need to run: dangerous-claude --login" >&2
    fi
  fi

  # Use mkdir for portable locking (atomic on all Unix systems)
  local lock_dir="$CLAUDE_STATE_DIR/.credentials.lock"
  local lock_acquired=false
  local max_attempts=10
  local attempt=0

  while [ "$attempt" -lt "$max_attempts" ]; do
    if mkdir "$lock_dir" 2>/dev/null; then
      lock_acquired=true
      break
    fi
    # Check if lock is stale (older than 60 seconds)
    if [ -d "$lock_dir" ]; then
      local lock_age
      lock_age=$(( $(date +%s) - $(stat -f %m "$lock_dir" 2>/dev/null || stat -c %Y "$lock_dir" 2>/dev/null || echo 0) ))
      if [ "$lock_age" -gt 60 ]; then
        rm -rf "$lock_dir" 2>/dev/null
        continue
      fi
    fi
    attempt=$((attempt + 1))
    sleep 0.5
  done

  if [ "$lock_acquired" = false ]; then
    echo "Warning: Could not acquire lock for credentials sync, skipping" >&2
    return 0
  fi

  # Ensure lock is released on exit from this function
  trap 'rm -rf "$lock_dir" 2>/dev/null' RETURN

  # Re-check if file was created while waiting for lock
  if [ -f "$credentials_file" ] && [ ! -L "$credentials_file" ]; then
    if jq -e . "$credentials_file" &>/dev/null; then
      return 0
    fi
  fi

  # Write credentials atomically using temp file + mv
  local temp_file
  temp_file=$(mktemp "$CLAUDE_STATE_DIR/.credentials.tmp.XXXXXX") || {
    echo "Error: Failed to create temp file for credentials sync" >&2
    return 0
  }

  # Set permissions before writing sensitive data
  if ! chmod 600 "$temp_file"; then
    echo "Error: Failed to set permissions on temp file" >&2
    rm -f "$temp_file" 2>/dev/null
    return 0
  fi

  # Write normalized JSON to temp file
  if ! printf '%s\n' "$normalized_data" > "$temp_file"; then
    echo "Error: Failed to write credentials to temp file" >&2
    rm -f "$temp_file" 2>/dev/null
    return 0
  fi

  # Final symlink check before move
  if [ -L "$credentials_file" ]; then
    echo "Error: $credentials_file became a symlink, refusing to write" >&2
    rm -f "$temp_file" 2>/dev/null
    return 0
  fi

  # Atomic move to final location
  if ! mv "$temp_file" "$credentials_file"; then
    echo "Error: Failed to move credentials file into place" >&2
    rm -f "$temp_file" 2>/dev/null
    return 0
  fi

  echo "Synced OAuth credentials from macOS Keychain" >&2
}

# Prepare config files for build (copy from .example if not present)
prepare_config_files() {
  # packages.apt - apt packages to install
  if [ ! -f "$SCRIPT_DIR/packages.apt" ]; then
    if [ -f "$SCRIPT_DIR/packages.apt.example" ]; then
      cp "$SCRIPT_DIR/packages.apt.example" "$SCRIPT_DIR/packages.apt"
      echo "Created packages.apt from packages.apt.example"
    else
      touch "$SCRIPT_DIR/packages.apt"
    fi
  fi

  # sdkman.txt - SDKMAN tools to install
  if [ ! -f "$SCRIPT_DIR/sdkman.txt" ]; then
    if [ -f "$SCRIPT_DIR/sdkman.txt.example" ]; then
      cp "$SCRIPT_DIR/sdkman.txt.example" "$SCRIPT_DIR/sdkman.txt"
      echo "Created sdkman.txt from sdkman.txt.example"
    else
      touch "$SCRIPT_DIR/sdkman.txt"
    fi
  fi
}

# Check if config files have been customized from the examples
is_customized() {
  # If packages.apt exists and differs from example, it's customized
  if [ -f "$SCRIPT_DIR/packages.apt" ] && [ -f "$SCRIPT_DIR/packages.apt.example" ]; then
    if ! diff -q "$SCRIPT_DIR/packages.apt" "$SCRIPT_DIR/packages.apt.example" &>/dev/null; then
      return 0
    fi
  fi

  # If sdkman.txt exists and differs from example, it's customized
  if [ -f "$SCRIPT_DIR/sdkman.txt" ] && [ -f "$SCRIPT_DIR/sdkman.txt.example" ]; then
    if ! diff -q "$SCRIPT_DIR/sdkman.txt" "$SCRIPT_DIR/sdkman.txt.example" &>/dev/null; then
      return 0
    fi
  fi

  return 1
}

# Upgrade dangerous-claude to the latest version
run_upgrade() {
  echo "Upgrading dangerous-claude..."
  echo ""

  # Check current branch
  local current_branch
  current_branch=$(git -C "$SCRIPT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null)

  if [ "$current_branch" != "main" ]; then
    echo "Warning: You are on branch '$current_branch', not 'main'."
    echo ""

    # Check if working directory is dirty
    local is_dirty=false
    if ! git -C "$SCRIPT_DIR" diff --quiet 2>/dev/null || ! git -C "$SCRIPT_DIR" diff --cached --quiet 2>/dev/null; then
      is_dirty=true
    fi

    if [ "$is_dirty" = true ]; then
      echo "Your working directory has uncommitted changes."
      echo ""
    fi

    # Ask user what to do
    echo "Would you like to switch to the main branch to get the latest updates?"
    if [ "$is_dirty" = true ]; then
      echo "(Your uncommitted changes will be stashed and can be restored later)"
    fi
    echo ""
    read -p "Switch to main branch? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
      # Stash changes if dirty
      if [ "$is_dirty" = true ]; then
        echo "Stashing uncommitted changes..."
        if ! git -C "$SCRIPT_DIR" stash push -m "dangerous-claude upgrade: auto-stash from $current_branch"; then
          echo "Error: Failed to stash changes"
          exit 1
        fi
        echo "Changes stashed. Use 'git -C $SCRIPT_DIR stash pop' to restore them later."
        echo ""
      fi

      # Switch to main
      echo "Switching to main branch..."
      if ! git -C "$SCRIPT_DIR" checkout main; then
        echo "Error: Failed to switch to main branch"
        exit 1
      fi
      echo ""
    else
      echo "Staying on '$current_branch' branch."
      echo "Note: You may not receive the latest updates."
      echo ""
    fi
  fi

  # Pull latest changes from git
  echo "Pulling latest changes..."
  if ! git -C "$SCRIPT_DIR" pull; then
    echo "Error: Failed to pull latest changes"
    exit 1
  fi

  echo ""

  # Re-run with --init to pull or build the image as appropriate
  # Use exec to replace this process with the updated script
  exec "$SCRIPT_DIR/dangerous-claude" --init
}

# Build locally
build_image() {
  echo "Building Docker image..."
  prepare_config_files
  docker build -t "$IMAGE_NAME" "$SCRIPT_DIR"
  echo ""
}

# Pull from GitHub Container Registry
pull_image() {
  echo "Pulling Docker image from GitHub Container Registry..."
  if docker pull "$REMOTE_IMAGE"; then
    docker tag "$REMOTE_IMAGE" "$IMAGE_NAME"
    echo ""
  else
    echo "Failed to pull image, building locally instead..."
    build_image
  fi
}

# Acquire image: build or pull as appropriate
if [ "$FORCE_BUILD" = true ]; then
  build_image
  echo "Docker image built successfully."
  exit 0
elif [ "$RUN_UPGRADE" = true ]; then
  run_upgrade
  # run_upgrade uses exec, so this line is never reached
elif [ "$INIT_IMAGE" = true ]; then
  # Smart pull-or-build: pull unless customized
  if is_customized; then
    echo "Custom configuration detected."
    build_image
  else
    pull_image
  fi
  echo "Docker image ready."
  exit 0
elif ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
  # Image doesn't exist locally
  if is_customized; then
    echo "Custom configuration detected."
    build_image
  else
    pull_image
  fi
fi

# Sync credentials from macOS Keychain before starting container
sync_keychain_credentials

# Build volume mounts
VOLUME_ARGS=()

# Mount Claude state for conversation persistence (symlinked to ~/.claude at runtime)
VOLUME_ARGS+=("-v" "$CLAUDE_STATE_DIR:/mnt/claude-data")

# Mount ~/.claude.json to a staging location (read-only)
# The entrypoint will copy it to the actual location, so each container
# gets its own writable copy and avoids conflicts when running multiple instances
CLAUDE_JSON="$HOME/.claude.json"
if [ -f "$CLAUDE_JSON" ]; then
  VOLUME_ARGS+=("-v" "$CLAUDE_JSON:/mnt/claude-config/.claude.json:ro")
fi

# Mount git config so commits appear as the user
if [ -f "$HOME/.gitconfig" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.gitconfig:/home/claude/.gitconfig:ro")
fi

# Mount Gradle directory for shared caches and configs
if [ -d "$HOME/.gradle" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.gradle:/home/claude/.gradle")
fi

# Mount Maven directory for shared caches and configs
if [ -d "$HOME/.m2" ]; then
  VOLUME_ARGS+=("-v" "$HOME/.m2:/home/claude/.m2")
fi

# Mount Docker socket if --docker flag is enabled
if [ "$ENABLE_DOCKER" = true ]; then
  # Check common Docker socket locations
  # Use a function to properly check sockets (including symlinks)
  check_docker_socket() {
    local sock="$1"
    # Check if path exists (file, socket, or symlink)
    if [ ! -e "$sock" ] && [ ! -L "$sock" ]; then
      return 1
    fi
    # For symlinks, resolve to actual path and verify it's a socket
    if [ -L "$sock" ]; then
      local resolved
      resolved=$(readlink -f "$sock" 2>/dev/null) || return 1
      [ -S "$resolved" ] && return 0
      return 1
    fi
    # Direct socket check
    [ -S "$sock" ] && return 0
    return 1
  }

  DOCKER_SOCK=""
  if check_docker_socket "/var/run/docker.sock"; then
    DOCKER_SOCK="/var/run/docker.sock"
  elif check_docker_socket "$HOME/.rd/docker.sock"; then
    # Rancher Desktop: mount socket directly (entrypoint.sh creates symlink inside container)
    echo "Docker: Found Rancher Desktop socket at ~/.rd/docker.sock"
    DOCKER_SOCK="$HOME/.rd/docker.sock"
  fi

  if [ -n "$DOCKER_SOCK" ]; then
    VOLUME_ARGS+=("-v" "$DOCKER_SOCK:/var/run/docker.sock")
    echo "Docker: Mounting $DOCKER_SOCK for container access"
  else
    echo "Warning: Docker socket not found"
    echo "  Checked: /var/run/docker.sock, ~/.rd/docker.sock"
    echo "  Make sure Docker is running on the host"
  fi
fi

# Function to check if a directory is a git worktree
is_git_worktree() {
  local dir="$1"
  local git_file="$dir/.git"
  # Worktrees have a .git file (not directory) containing "gitdir: ..."
  [ -f "$git_file" ] && grep -q "^gitdir:" "$git_file" 2>/dev/null
}

# Mount each directory and build ordered list for entrypoint
WORKSPACE_ORDER=()
for dir in "${DIRECTORIES[@]}"; do
  # Get absolute path
  abs_path="$(cd "$dir" 2>/dev/null && pwd)" || {
    echo "Error: Directory not found: $dir"
    exit 1
  }

  # Use the directory name as the mount point
  dir_name="$(basename "$abs_path")"

  VOLUME_ARGS+=("-v" "$abs_path:/workspace/$dir_name")
  WORKSPACE_ORDER+=("/workspace/$dir_name")
  echo "Mounting: $abs_path -> /workspace/$dir_name"

  # Warn if this is a git worktree
  if is_git_worktree "$abs_path"; then
    echo ""
    echo "  WARNING: This is a git worktree."
    echo "  Git commits will NOT work without access to the parent repository."
    echo "  File reading and editing will work normally."
    echo "  To enable commits, mount the main repository instead."
    echo ""
  fi
done

# If no directories specified, mount current directory
if [ ${#DIRECTORIES[@]} -eq 0 ]; then
  abs_path="$(pwd)"
  dir_name="$(basename "$abs_path")"
  VOLUME_ARGS+=("-v" "$abs_path:/workspace/$dir_name")
  WORKSPACE_ORDER+=("/workspace/$dir_name")
  echo "Mounting current directory: $abs_path -> /workspace/$dir_name"
fi

echo ""

# Build environment variables
ENV_ARGS=()

# Determine API key: prefer env var, fall back to keychain
# KEYCHAIN_API_KEY is set by sync_keychain_credentials() if an API key was found
if [ -n "$ANTHROPIC_API_KEY" ]; then
  ENV_ARGS+=("-e" "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY")
elif [ -n "$KEYCHAIN_API_KEY" ]; then
  ENV_ARGS+=("-e" "ANTHROPIC_API_KEY=$KEYCHAIN_API_KEY")
  echo "Using API key from macOS Keychain"
fi

# Prepare env.txt from example if not present
if [ ! -f "$SCRIPT_DIR/env.txt" ]; then
  if [ -f "$SCRIPT_DIR/env.txt.example" ]; then
    cp "$SCRIPT_DIR/env.txt.example" "$SCRIPT_DIR/env.txt"
  else
    touch "$SCRIPT_DIR/env.txt"
  fi
fi

# Pass environment variables listed in env.txt
if [ -f "$SCRIPT_DIR/env.txt" ]; then
  while IFS= read -r var_name || [ -n "$var_name" ]; do
    # Skip comments and empty lines
    [[ "$var_name" =~ ^#.*$ || -z "$var_name" ]] && continue
    # Only pass if the variable is set in the environment
    if [ -n "${!var_name}" ]; then
      ENV_ARGS+=("-e" "$var_name=${!var_name}")
    fi
  done < "$SCRIPT_DIR/env.txt"
fi

if [ -n "$CONTINUE_FLAG" ]; then
  ENV_ARGS+=("-e" "CLAUDE_CONTINUE=true")
fi

if [ -n "$RESUME_ID" ]; then
  ENV_ARGS+=("-e" "CLAUDE_RESUME=$RESUME_ID")
fi

# Pass Docker enabled flag to entrypoint for group permission setup
if [ "$ENABLE_DOCKER" = true ]; then
  ENV_ARGS+=("-e" "DOCKER_ENABLED=true")
fi

# Pass workspace directory order to entrypoint (colon-separated)
if [ ${#WORKSPACE_ORDER[@]} -gt 0 ]; then
  WORKSPACE_ORDER_STR=$(IFS=:; echo "${WORKSPACE_ORDER[*]}")
  ENV_ARGS+=("-e" "WORKSPACE_ORDER=$WORKSPACE_ORDER_STR")
fi

# Determine the command to run
if [ "$RUN_LOGIN" = true ]; then
  DOCKER_CMD="claude login"
elif [ "$START_SHELL" = true ]; then
  DOCKER_CMD="bash"
else
  DOCKER_CMD=""
fi

# Run the container
exec docker run \
  --rm \
  -it \
  --name "$CONTAINER_NAME" \
  "${VOLUME_ARGS[@]}" \
  "${ENV_ARGS[@]}" \
  "$IMAGE_NAME" \
  $DOCKER_CMD
